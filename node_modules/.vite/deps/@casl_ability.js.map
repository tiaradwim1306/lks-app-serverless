{
  "version": 3,
  "sources": ["../../@ucast/core/src/Condition.ts", "../../@ucast/core/src/utils.ts", "../../@ucast/core/src/builder.ts", "../../@ucast/core/src/parsers/defaultInstructionParsers.ts", "../../@ucast/core/src/parsers/ObjectQueryParser.ts", "../../@ucast/core/src/interpreter.ts", "../../@ucast/core/src/translator.ts", "../../@ucast/core/src/index.ts", "../../@ucast/mongo/src/instructions.ts", "../../@ucast/mongo/src/MongoQueryParser.ts", "../../@ucast/mongo/src/index.ts", "../../@ucast/js/src/utils.ts", "../../@ucast/js/src/interpreter.ts", "../../@ucast/js/src/interpreters.ts", "../../@ucast/js/src/defaults.ts", "../../@ucast/mongo2js/src/factory.ts", "../../@casl/ability/dist/es6m/index.mjs"],
  "sourcesContent": ["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n", "import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n", "import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n", "import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n", "import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n", "import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n", "import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n", "import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n", "import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n", "import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n", "import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n", "import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n", "import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n", "import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n", "import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n", "import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n", "import{createFactory as t,$eq as e,$ne as i,$lt as s,$lte as n,$gt as r,$gte as o,$in as c,$nin as u,$all as h,$size as l,$regex as a,$options as f,$elemMatch as d,$exists as y,eq as b,ne as p,lt as w,lte as g,gt as $,gte as A,within as j,nin as M,all as m,size as E,regex as v,elemMatch as x,exists as F,and as _}from\"@ucast/mongo2js\";function O(t){return Array.isArray(t)?t:[t]}const C=Object.hasOwn||Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);const R=\"__caslSubjectType__\";function P(t,e){if(e)if(!C(e,R))Object.defineProperty(e,R,{value:t});else if(t!==e[R])throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${e[R]}`);return e}const S=t=>{const e=typeof t;return\"string\"===e||\"function\"===e};const T=t=>t.modelName||t.name;const B=t=>\"string\"===typeof t?t:T(t);function q(t){if(C(t,R))return t[R];return T(t.constructor)}function z(t,e,i){let s=O(e);let n=0;while(n<s.length){const e=s[n++];if(C(t,e))s=i(s,t[e])}return s}function D(t,e){if(\"string\"===typeof e&&-1!==t.indexOf(e))return e;for(let i=0;i<e.length;i++)if(-1!==t.indexOf(e[i]))return e[i];return null}const Y=(t,e)=>t.concat(e);function k(t,e){if(e in t)throw new Error(`Cannot use \"${e}\" as an alias because it's reserved action.`);const i=Object.keys(t);const s=(t,i)=>{const s=D(t,i);if(s)throw new Error(`Detected cycle ${s} -> ${t.join(\", \")}`);const n=\"string\"===typeof i&&i===e||-1!==t.indexOf(e)||Array.isArray(i)&&-1!==i.indexOf(e);if(n)throw new Error(`Cannot make an alias to \"${e}\" because this is reserved action`);return t.concat(i)};for(let e=0;e<i.length;e++)z(t,i[e],s)}function I(t,e){if(!e||false!==e.skipValidate)k(t,e&&e.anyAction||\"manage\");return e=>z(t,e,Y)}function L(t,e,i){for(let s=i;s<e.length;s++)t.push(e[s])}function U(t,e){if(!t||!t.length)return e||[];if(!e||!e.length)return t||[];let i=0;let s=0;const n=[];while(i<t.length&&s<e.length)if(t[i].priority<e[s].priority){n.push(t[i]);i++}else{n.push(e[s]);s++}L(n,t,i);L(n,e,s);return n}function G(t,e,i){let s=t.get(e);if(!s){s=i();t.set(e,s)}return s}const H=t=>t;function J(t,e){if(Array.isArray(t.fields)&&!t.fields.length)throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");if(t.fields&&!e.fieldMatcher)throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');if(t.conditions&&!e.conditionsMatcher)throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions')}class K{constructor(t,e,i=0){J(t,e);this.action=e.resolveAction(t.action);this.subject=t.subject;this.inverted=!!t.inverted;this.conditions=t.conditions;this.reason=t.reason;this.origin=t;this.fields=t.fields?O(t.fields):void 0;this.priority=i;this.t=e}i(){if(this.conditions&&!this.o)this.o=this.t.conditionsMatcher(this.conditions);return this.o}get ast(){const t=this.i();return t?t.ast:void 0}matchesConditions(t){if(!this.conditions)return true;if(!t||S(t))return!this.inverted;const e=this.i();return e(t)}matchesField(t){if(!this.fields)return true;if(!t)return!this.inverted;if(this.fields&&!this.u)this.u=this.t.fieldMatcher(this.fields);return this.u(t)}}function N(t,e){const i={value:t,prev:e,next:null};if(e)e.next=i;return i}function Q(t){if(t.next)t.next.prev=t.prev;if(t.prev)t.prev.next=t.next;t.next=t.prev=null}const V=t=>({value:t.value,prev:t.prev,next:t.next});const W=()=>({rules:[],merged:false});const X=()=>new Map;class Z{constructor(t=[],e={}){this.h=false;this.l={conditionsMatcher:e.conditionsMatcher,fieldMatcher:e.fieldMatcher,resolveAction:e.resolveAction||H};this.p=e.anyAction||\"manage\";this.g=e.anySubjectType||\"all\";this.$=e.detectSubjectType||q;this.A=t;this.j=this.M(t)}get rules(){return this.A}detectSubjectType(t){if(S(t))return t;if(!t)return this.g;return this.$(t)}update(t){const e={rules:t,ability:this,target:this};this.m(\"update\",e);this.A=t;this.j=this.M(t);this.m(\"updated\",e);return this}M(t){const e=new Map;for(let i=t.length-1;i>=0;i--){const s=t.length-i-1;const n=new K(t[i],this.l,s);const r=O(n.action);const o=O(n.subject||this.g);if(!this.h&&n.fields)this.h=true;for(let t=0;t<o.length;t++){const i=G(e,o[t],X);for(let t=0;t<r.length;t++)G(i,r[t],W).rules.push(n)}}return e}possibleRulesFor(t,e=this.g){if(!S(e))throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');const i=G(this.j,e,X);const s=G(i,t,W);if(s.merged)return s.rules;const n=t!==this.p&&i.has(this.p)?i.get(this.p).rules:void 0;let r=U(s.rules,n);if(e!==this.g)r=U(r,this.possibleRulesFor(t,this.g));s.rules=r;s.merged=true;return r}rulesFor(t,e,i){const s=this.possibleRulesFor(t,e);if(i&&\"string\"!==typeof i)throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");if(!this.h)return s;return s.filter((t=>t.matchesField(i)))}actionsFor(t){if(!S(t))throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');const e=new Set;const i=this.j.get(t);if(i)Array.from(i.keys()).forEach((t=>e.add(t)));const s=t!==this.g?this.j.get(this.g):void 0;if(s)Array.from(s.keys()).forEach((t=>e.add(t)));return Array.from(e)}on(t,e){this.v=this.v||new Map;const i=this.v;const s=i.get(t)||null;const n=N(e,s);i.set(t,n);return()=>{const e=i.get(t);if(!n.next&&!n.prev&&e===n)i.delete(t);else if(n===e)i.set(t,n.prev);Q(n)}}m(t,e){if(!this.v)return;let i=this.v.get(t)||null;while(null!==i){const t=i.prev?V(i.prev):null;i.value(e);i=t}}}class PureAbility extends Z{can(t,e,i){const s=this.relevantRuleFor(t,e,i);return!!s&&!s.inverted}relevantRuleFor(t,e,i){const s=this.detectSubjectType(e);const n=this.rulesFor(t,s,i);for(let t=0,i=n.length;t<i;t++)if(n[t].matchesConditions(e))return n[t];return null}cannot(t,e,i){return!this.can(t,e,i)}}const tt={$eq:e,$ne:i,$lt:s,$lte:n,$gt:r,$gte:o,$in:c,$nin:u,$all:h,$size:l,$regex:a,$options:f,$elemMatch:d,$exists:y};const et={eq:b,ne:p,lt:w,lte:g,gt:$,gte:A,in:j,nin:M,all:m,size:E,regex:v,elemMatch:x,exists:F,and:_};const it=(e,i,s)=>t(Object.assign({},tt,e),Object.assign({},et,i),s);const st=t(tt,et);const nt=/[-/\\\\^$+?.()|[\\]{}]/g;const rt=/\\.?\\*+\\.?/g;const ot=/\\*+/;const ct=/\\./g;function ut(t,e,i){const s=\"*\"===i[0]||\".\"===t[0]&&\".\"===t[t.length-1]?\"+\":\"*\";const n=-1===t.indexOf(\"**\")?\"[^.]\":\".\";const r=t.replace(ct,\"\\\\$&\").replace(ot,n+s);return e+t.length===i.length?`(?:${r})?`:r}function ht(t,e,i){if(\".\"===t&&(\"*\"===i[e-1]||\"*\"===i[e+1]))return t;return`\\\\${t}`}function lt(t){const e=t.map((t=>t.replace(nt,ht).replace(rt,ut)));const i=e.length>1?`(?:${e.join(\"|\")})`:e[0];return new RegExp(`^${i}$`)}const at=t=>{let e;return i=>{if(\"undefined\"===typeof e)e=t.every((t=>-1===t.indexOf(\"*\")))?null:lt(t);return null===e?-1!==t.indexOf(i):e.test(i)}};class Ability extends PureAbility{constructor(t=[],e={}){super(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}}function createMongoAbility(t=[],e={}){return new PureAbility(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}function isAbilityClass(t){return\"function\"===typeof t.prototype.possibleRulesFor}class ft{constructor(t){this.F=t}because(t){this.F.reason=t;return this}}class AbilityBuilder{constructor(t){this.rules=[];this._=t;this.can=(t,e,i,s)=>this.O(t,e,i,s,false);this.cannot=(t,e,i,s)=>this.O(t,e,i,s,true);this.build=t=>isAbilityClass(this._)?new this._(this.rules,t):this._(this.rules,t)}O(t,e,i,s,n){const r={action:t};if(n)r.inverted=n;if(e){r.subject=e;if(Array.isArray(i)||\"string\"===typeof i)r.fields=i;else if(\"undefined\"!==typeof i)r.conditions=i;if(\"undefined\"!==typeof s)r.conditions=s}this.rules.push(r);return new ft(r)}}function defineAbility(t,e){const i=new AbilityBuilder(createMongoAbility);const s=t(i.can,i.cannot);if(s&&\"function\"===typeof s.then)return s.then((()=>i.build(e)));return i.build(e)}const dt=t=>`Cannot execute \"${t.action}\" on \"${t.subjectType}\"`;const yt=function t(e){this.message=e};yt.prototype=Object.create(Error.prototype);class ForbiddenError extends yt{static setDefaultMessage(t){this.C=\"string\"===typeof t?()=>t:t}static from(t){return new this(t)}constructor(t){super(\"\");this.ability=t;if(\"function\"===typeof Error.captureStackTrace){this.name=\"ForbiddenError\";Error.captureStackTrace(this,this.constructor)}}setMessage(t){this.message=t;return this}throwUnlessCan(t,e,i){const s=this.unlessCan(t,e,i);if(s)throw s}unlessCan(t,e,i){const s=this.ability.relevantRuleFor(t,e,i);if(s&&!s.inverted)return;this.action=t;this.subject=e;this.subjectType=B(this.ability.detectSubjectType(e));this.field=i;const n=s?s.reason:\"\";this.message=this.message||n||this.constructor.C(this);return this}}ForbiddenError.C=dt;var bt=Object.freeze({__proto__:null});export{Ability,AbilityBuilder,ForbiddenError,PureAbility,it as buildMongoQueryMatcher,I as createAliasResolver,createMongoAbility,defineAbility,q as detectSubjectType,at as fieldPatternMatcher,dt as getDefaultErrorMessage,bt as hkt,st as mongoQueryMatcher,P as subject,O as wrapArray};\n//# sourceMappingURL=index.mjs.map\n"],
  "mappings": ";;;AAMO,IAAeA,IAAf,MAAeA;EAGpBC,YACkBC,IACAC,IAAAA;AAAAA,SADAD,WAAAA,IAAAA,KACAC,QAAAA,IAEhBC,OAAOC,eAAeC,MAAM,KAAU,EACpCC,UAAAA,KAAU,CAAA;EAAA;EAAA,IAAA,QAAA;AAAA,WAKLD,KAAKE;EAAAA;EAGdC,QAAQC,IAAAA;AAAAA,SACDF,IAASF,KAAKE,KAAU,CAAA,GAAA,KACxBA,EAAOG,KAAKD,EAAAA;EAAAA;AAAAA;AAId,IAAME,IAAN,cAAmCZ,EAAAA;AAAAA;AAGnC,IAAMa,IAAN,cAAiED,EAAAA;EACtEX,YAAYC,IAAkBY,IAAAA;AAAAA,QAAAA,CACvBC,MAAMC,QAAQF,EAAAA;AAAAA,YACX,IAAIG,MAAO,IAAGf,wDAAAA;AAAAA,UAGhBA,IAAUY,EAAAA;EAAAA;AAAAA;AAAAA,IAIPI,IAAS;AACf,IAAMC,IAAN,cAA0CnB,EAAAA;EAG/CC,YAAYC,IAAkBkB,IAA+BjB,IAAAA;AAAAA,UACrDD,IAAUC,EAAAA,GAAAA,KACXiB,QAAQA;EAAAA;AAAAA;AAAAA,IAIJC,IAAiB,IAAIT,EAAkB,YAAY,IAAA;AAJ/CQ,IC7CXE,IAAiBlB,OAAOmB,UAAUD,eAAeE,KAAKC,KAAKrB,OAAOmB,UAAUD,cAAAA;AAE3E,SAASI,EAAWxB,IAAkByB,IAAAA;AAAAA,SACpCA,cAAqBd,KAAqBc,GAAUzB,aAAaA;AAAAA;AAuBnE,SAAS0B,EAAgD1B,IAAkBY,IAAAA;AAAAA,SACtD,MAAtBA,GAAWe,SACNf,GAAW,CAAA,IAGb,IAAID,EAAkBX,IAzB/B,SAAS4B,GACP5B,IACAY,IACAiB,IAAAA;AAAAA,UAEMC,KAAsBD,MAAoB,CAAA;AAAA,aAEvCE,KAAI,GAAGJ,KAASf,GAAWe,QAAQI,KAAIJ,IAAQI,MAAK;AAAA,YACrDC,KAAcpB,GAAWmB,EAAAA;AAE3BP,QAAWxB,IAAUgC,EAAAA,IACvBJ,GAAkB5B,IAAUgC,GAAY/B,OAAc6B,EAAAA,IAEtDA,GAAerB,KAAKuB,EAAAA;IAAAA;AAAAA,WAIjBF;EAAAA,EAQkD9B,IAAUY,EAAAA,CAAAA;AAAAA;AAAAA,IAGxDqB,IAAeC,CAAAA,OAASA;AAHgCtB,IAIxDuB,IAAS,MAAMjC,uBAAOkC,OAAO,IAAA;AAJ2BxB,IAMxDyB,IAA2BnC,OAAOC,eAAegC,EAAAA,GAAU,cAAc,EACpFlC,OAAO,eAAA,CAAA;AAMF,SAASqC,EACdrC,IACAsC,IACAC,KAAAA,OAAa;AAAA,MAAA,CAERvC,MAASA,MAASA,GAAMF,gBAAgBG;AAAAA,WAAAA;AACpC,aAGEuC,MAAQxC,IAAO;AAAA,QACRmB,EAAenB,IAAOwC,EAAAA,KAASrB,EAAemB,IAAcE,EAAAA,MAAAA,CAC3DD,MAAcvC,GAAMwC,EAAAA,MAAUJ;AAAAA,aAAAA;EACtC;AAAA,SAAA;AAIJ;AAGF,SAASK,EAAqBC,IAAAA;AAAAA,QAC7BC,KAAiB,CAAA;AAAA,aACZC,MAAOF;AACZvB,MAAeuB,IAAWE,EAAAA,KAAQF,GAAUE,EAAAA,MAASR,KACvDO,GAAKnC,KAAKoC,EAAAA;AAAAA,SAIPD;AAAAA;AAGF,SAASE,EAAuBlC,IAAyBa,IAAAA;AAC1DA,EAAAA,OAAcN,KAChBP,GAAWH,KAAKgB,EAAAA;AAAAA;AAAAA,IC3EPsB,IAAYnC,CAAAA,OAA4Bc,EAA2B,OAAOd,EAAAA;AD2EnEoC,IE7DPC,IAA4C,EACvDC,SAASC,IAAaC,IAAOC,IAAAA;AAAAA,QAErBC,MADUC,MAAMC,QAAQJ,EAAAA,IAASA,KAAQ,CAACA,EAAAA,GACrBK,IAAIC,CAAAA,OAASL,GAAQM,MAAMD,EAAAA,CAAAA;AAAAA,SAC/C,IAAIE,EAAkBT,GAAYU,MAAMP,EAAAA;AAAAA,GAEjDQ,OAAK,CAACX,IAAaC,IAAOC,OACjB,IAAIU,EAAeZ,GAAYU,MAAMR,GAAQS,OAAOV,EAAAA,GAE7DY,UAAQ,CAACb,IAAaC,OACb,IAAIa,EAAkBd,GAAYU,MAAMT,EAAAA,EAAAA;ACU5C,IAAMc,IAAN,MAAMA;EAaXC,YAAYC,IAAkDC,KAAwBC,EAAAA,GAAAA;AAAAA,SATrEC,IAAAA,QAAAA,KACTC,IAAAA,QAAAA,KACAC,IAAAA,QAAAA,KACSC,IAAAA,QAAAA,KAIAC,IAAAA,QAAAA,KAGVhB,QAAQiB,KAAKjB,MAAMkB,KAAKD,IAAAA,GAAAA,KACxBF,IAAW,EACdI,yBAAyBT,GAAQS,2BAA2BC,GAC5DC,qBAAqBX,GAAQW,uBAAuB,MACpDC,sBAAsBZ,GAAQY,wBAAwBC,EAAAA,GAAAA,KAEnDX,IAAgBY,OAAOC,KAAKhB,EAAAA,EAAciB,OAAO,CAACC,IAAKzB,QAC1DyB,GAAIzB,EAAAA,IAAAA,OAAAA,OAAAA,EAAUA,MAAMe,KAAKF,EAASI,wBAAwBjB,EAAAA,EAAAA,GAAUO,GAAaP,EAAAA,CAAAA,GAC1EyB,KACN,CAAA,CAAA,GAAA,KACEd,IAAAA,OAAAA,OAAAA,CAAAA,GACAH,GAAQkB,cAAAA,EACXzB,OAAO,IACPJ,OAAO,CAAA,GACPC,OAAOiB,KAAKjB,OACZ6B,cAAkBpC,CAAAA,OAA+BoC,EAC/CpC,IACAwB,KAAKL,GACLF,GAAQoB,cAAAA,EAAAA,CAAAA,GAAAA,KAGPhB,IAAAA,OAAAA,OAAAA,CAAAA,GACAJ,GAAQqB,iBAAAA,EACX/B,OAAOiB,KAAKjB,OACZD,OAAO,CAAA,EAAA,CAAA,GAAA,KAEJiB,IAAcN,GAAQoB,iBAAiBE,IAAuBR,OAAOC;EAAAA;EAG5EQ,SAASjC,IAAAA;AAAAA,SACFA,QAAQA,IAAAA,KACRa,EAAyBb,QAAQA,IAAAA,KACjCc,EAA4Bd,QAAQA;EAAAA;EAGjCkC,WAAW/B,IAAegC,IAAkB1C,IAAgB2C,IAAAA;AAAAA,UAC9D5C,KAAcyB,KAAKL,EAAcuB,EAAAA;AAAAA,QAAAA,CAElC3C;AAAAA,YACG,IAAI6C,MAAO,yBAAwBF,KAAAA;AAAAA,QAGlB,YAArB3C,GAAY8C;AAAAA,YACR,IAAID,MAAO,cAAa7C,GAAY8C,kBAAkBH,oBAAAA;AAAAA,WAAAA,KAGzDtB,EAAyBV,QAAQA,IAAAA,KACjCU,EAAyBd,QAAQqC,IAE/BnB,KAAKsB,iBAAiB/C,IAAaC,IAAOwB,KAAKJ,CAAAA;EAAAA;EAI9C0B,iBACR/C,IACAC,IACAC,IAAAA;AAEoC,kBAAA,OAAzBF,GAAYgD,YACrBhD,GAAYgD,SAAShD,IAAaC,EAAAA;AAAAA,YAGID,GAAYQ,SAC/CV,EAA0BE,GAAY8C,IAAAA,GAC9B9C,IAAaC,IAAOC,EAAAA;EAAAA;EAGzB+C,oBAAoBtC,IAAeV,IAAAA;AAAAA,UACrCE,KAA0B,CAAA,GAC1B8B,KAAOR,KAAKD,EAAYvB,EAAAA;AAAAA,aAErBiD,KAAI,GAAGC,KAASlB,GAAKkB,QAAQD,KAAIC,IAAQD,MAAK;AAAA,YAC/CE,KAAKnB,GAAKiB,EAAAA;AAAAA,UAAAA,CACIzB,KAAKL,EAAcgC,EAAAA;AAAAA,cAG/B,IAAIP,MAAO,oBAAmBlC,6DAAAA;AAItC0C,QAAuBlD,IADLsB,KAAKiB,WAAW/B,IAAOyC,IAAInD,GAAMmD,EAAAA,GAAgBnD,EAAAA,CAAAA;IAAAA;AAAAA,WAI9DE;EAAAA;EAGTK,MAAmBD,IAAAA;AAAAA,UACXJ,KAAa,CAAA,GACb8B,KAAOR,KAAKD,EAAYjB,EAAAA;AAAAA,SAEzBe,EAA4Bf,QAAQA;AAAAA,aAEhC2C,KAAI,GAAGC,KAASlB,GAAKkB,QAAQD,KAAIC,IAAQD,MAAK;AAAA,YAC/CI,KAAMrB,GAAKiB,EAAAA,GACXjD,KAAQM,GAAM+C,EAAAA,GACdtD,KAAcyB,KAAKL,EAAckC,EAAAA;AAAAA,UAEnCtD,IAAa;AAAA,YACU,eAArBA,GAAY8C,QAA4C,eAArB9C,GAAY8C;AAAAA,gBAC3C,IAAID,MAAO,gDAA+CS,+DAAgEtD,GAAY8C,eAAAA;AAG9IO,UACElD,IACAsB,KAAKsB,iBAAiB/C,IAAaC,IAAOwB,KAAKH,CAAAA,CAAAA;MAAAA;AAExCG,aAAKJ,EAAyBgB,aAAgBpC,EAAAA,IACvDE,GAAWoD,KAAAA,GAAQ9B,KAAKwB,oBAAoBK,IAAKrD,EAAAA,CAAAA,IAEjDoD,EACElD,IACAsB,KAAKiB,WAAWY,IAAK7B,KAAKF,EAASM,qBAAqB5B,IAAOM,EAAAA,CAAAA;IAAAA;AAAAA,WAK9DkB,KAAKF,EAASO,qBAAqB3B,EAAAA;EAAAA;AAAAA;ACnJ9C,SAASqD,EACPC,IACAd,IAAAA;AAAAA,QAEMe,KAAYD,GAAad,EAAAA;AAAAA,MAEN,cAAA,OAAde;AAAAA,UACH,IAAIb,MAAO,wBAAuBF,+DAAAA;AAAAA,SAGnCe;AAAAA;AAQT,SAASC,EAAuB9D,IAAAA;AAAAA,SACvBA,GAAU8C;AAAAA;AAGZ,SAASiB,EACdH,IACAI,IAAAA;AAAAA,QAEM3C,KAAU2C,IACVC,KAAqB5C,MAAWA,GAAQ4C,sBAAsBH;AAAAA,MAChED;AAAAA,UAEIxC,KAAUA,GAAQ6C,oBAAoB,GAAA;IAAA,KACvC;AACHL,MAAAA,KAAc7D,CAAAA,OAAAA;AAAAA,cACNmE,KAAkBF,GAAmBjE,IAAWqB,EAAAA;AAAAA,eAC5BsC,EAAeC,IAAcO,EAAAA,EAC9BnE,IAAWoE,EAAAA;MAAAA;AAAAA;IAAAA,KAGnC;AACHP,MAAAA,KAAa,CAAC7D,IAAWI,IAAOiE,OAAAA;AAAAA,cACxBF,KAAkBF,GAAmBjE,IAAWqB,EAAAA;AAAAA,eAC5BsC,EAAeC,IAAcO,EAAAA,EAC9BnE,IAAWI,IAAOiE,IAAQD,EAAAA;MAAAA;AAAAA;IAAAA;AAIrDP,MAAAA,KAAa,CAAC7D,IAAWI,OAAAA;AAAAA,cACjB+D,KAAkBF,GAAmBjE,IAAWqB,EAAAA;AAAAA,eAC5BsC,EAAeC,IAAcO,EAAAA,EAC9BnE,IAAWI,IAAOgE,EAAAA;MAAAA;EAAAA;AAAAA,QAK3CA,KAAAA,OAAAA,OAAAA,CAAAA,GACD/C,IAAAA,EACHwC,WAAAA,GAAAA,CAAAA;AAAAA,SAGKO,GAAeP;AAAAA;ACvEjB,SAASS,EACd3D,IACAkD,IAAAA;AAAAA,SAEO,CAACnD,OAAgB6D,OAAAA;AAAAA,UAChBC,KAAM7D,GAAMD,IAAAA,GAAU6D,EAAAA,GACtBE,KAAaZ,GAAkBhC,KAAK,MAAM2C,EAAAA;AAAAA,WAChDC,GAAUD,MAAMA,IACTC;EAAAA;AAAAA;AAAAA,ICQEvB,IAAoBhC,EAAkBwD,UAAkBxB;;;ACRrE,SAASyB,GAAcC,IAA+BC,IAAAA;AAAAA,MAAAA,CAC/CC,MAAMC,QAAQF,EAAAA;AAAAA,UACX,IAAIG,MAAO,IAAGJ,GAAYK,oCAAAA;AAAAA;AAIpC,SAASC,GAAsBN,IAA+BC,IAAAA;AAAAA,MAC5DF,GAAcC,IAAaC,EAAAA,GAAAA,CAEtBA,GAAMM;AAAAA,UACH,IAAIH,MAAO,IAAGJ,GAAYK,qDAAAA;AAAAA;AAYpC,IAAMG,KAAYC,CAAAA,OAAiB,CAACT,IAA+BC,OAAAA;AAAAA,MAAAA,OACtDA,OAAUQ;AAAAA,UACb,IAAIL,MAAO,IAAGJ,GAAYK,gCAAgCI,KAAAA;AAAAA;AAFpE,IAMaC,KAA+C,EAC1DD,MAAM,YACNE,UAAUL,IACVM,MAAMZ,IAAaa,IAAAA,EAASD,OAAEA,GAAAA,GAAAA;AAAAA,QACtBE,KAAaD,GAAQE,IAAIC,CAAAA,OAASJ,GAAMI,EAAAA,CAAAA;AAAAA,SACvCC,EAA2BjB,GAAYK,MAAMS,EAAAA;AAAAA,EAAAA;AAXxD,IAcaI,KAAMR;AAdnB,IAeaS,KAA+C,EAC1DV,MAAM,YACNE,UAAUL,GAAAA;AAjBZ,IAoBac,KAAmD,EAC9DX,MAAM,SACNE,SAASX,IAAaC,IAAAA;AAAAA,MAAAA,EACJA,OAAUA,cAAiBoB,UAAUpB,GAAMqB,gBAAgBC;AAAAA,UAGnE,IAAInB,MAAO,IAAGJ,GAAYK,iFAAAA;AAAAA,GAGpCO,MAAMZ,IAAaC,IAAOuB,IAAAA;AAAAA,QAClBC,KAAYxB,cAAiBoB,SAC/B,IAAIK,EAAe,SAAoCF,GAAQG,OAAO1B,EAAAA,IACtEuB,GAAQZ,MAAMX,IAAOuB,EAAAA;AAAAA,SAElB,IAAII,EAAkB5B,GAAYK,MAAM,CAACoB,EAAAA,CAAAA;AAAAA,EAAAA;AAlCpD,IAqCaI,IAAgF,EAC3FpB,MAAM,SACNE,SAASX,IAAaC,IAAAA;AAAAA,MAAAA,CACfA,MAASA,GAAMqB,gBAAgBC;AAAAA,UAC5B,IAAInB,MAAO,IAAGJ,GAAYK,+EAAAA;AAAAA,GAGpCO,MAAMZ,IAAaC,IAAAA,EAAOW,OAAEA,IAAFe,OAASA,IAATG,cAAgBA,GAAAA,GAAAA;AAAAA,QAClCL,KAAYK,GAAa7B,EAAAA,IAASW,GAAMX,IAAO,EAAE0B,OAAOI,EAAAA,CAAAA,IAAYnB,GAAMX,EAAAA;AAAAA,SACzE,IAAIyB,EAAe1B,GAAYK,MAAMsB,IAAOF,EAAAA;AAAAA,EAAAA;AA9CvD,IAkDaO,KAAkC,EAC7CvB,MAAM,SACNE,UAAUH,GAAS,QAAA,EAAA;AApDrB,IAsDayB,KAAmC,EAC9CxB,MAAM,SACNE,UAAUZ,GAAAA;AAxDZ,IA0DamC,KAAOD;AA1DpB,IA2DaE,KAAOF;AA3DpB,IA4DaG,KAA2C,EACtD3B,MAAM,SACNE,SAASX,IAAaC,IAAAA;AAAAA,MAAAA,CACfC,MAAMC,QAAQF,EAAAA,KAA2B,MAAjBA,GAAMM;AAAAA,UAC3B,IAAIH,MAAO,IAAGJ,GAAYK,gDAAAA;AAAAA,EAAAA;AAhEtC,IAqEagC,KAAqC,EAChD5B,MAAM,SACNE,UAAUH,GAAS,SAAA,EAAA;AAvErB,IA0Ea8B,IAAqC,EAChD7B,MAAM,SACNE,UApFF,SAA4BX,IAA+BC,IAAAA;AAAAA,MAAAA,EACnB,YAAA,OAAVA,MAAuC,YAAA,OAAVA,MAAsBA,cAAiBsC;AAAAA,UAGxF,IAAInC,MAAO,IAAGJ,GAAYK,qEAAAA;AAAAA,EAAAA;AAIpC,IA8EamC,IAAMF;AA9EnB,IA+EaG,IAAMD;AA/EnB,IAgFaE,KAAOF;AAhFpB,IAkFaG,KAAwB,EACnClC,MAAM,QAAA;AAnFR,IAqFamC,IAAMD;AArFnB,IA6FaE,KAAgE,EAC3EpC,MAAM,SACNE,SAASX,IAAaC,IAAAA;AAAAA,MAAAA,EACdA,cAAiBoB,WAA4B,YAAA,OAAVpB;AAAAA,UACjC,IAAIG,MAAO,IAAGJ,GAAYK,+FAAAA;AAAAA,GAGpCO,MAAMZ,IAAa8C,IAAUtB,IAAAA;AAAAA,QACrBvB,KAA4B,YAAA,OAAb6C,KACjB,IAAIzB,OAAOyB,IAAUtB,GAAQR,MAAM+B,YAAY,EAAA,IAC/CD;AAAAA,SACG,IAAIpB,EAAe1B,GAAYK,MAAMmB,GAAQG,OAAO1B,EAAAA;AAAAA,EAAAA;AAxG/D,IA2Ga8C,IAA6B,EACxCtC,MAAM,SACNG,OAAO,MAAMoC,EAAAA;AA7Gf,IAgHaC,IAA6C,EACxDxC,MAAM,YACNE,UAAUH,GAAS,UAAA,EAAA;AAAA,IAAA,IAAA,OAAA,OAAA,EAAA,WAAA,MAAA,MAAA0C,IAAA,KAAAC,IAAA,MAAAC,IAAA,MAAAC,IAAA,YAAA,GAAA,OAAAC,IAAA,KAAAC,IAAA,MAAAC,IAAA,MAAAC,IAAA,MAAAC,IAAA,SAAAC,IAAA,MAAA,GAAA,KAAA,GAAA,KAAA,GAAA,MAAAC,IAAA,KAAAC,IAAA,KAAA,GAAA,QAAAC,IAAA,UAAA,GAAA,QAAA,EAAA,CAAA;AC3Id,IAAMC,IAAN,cAA+BC,EAAAA;EACpC1C,YAAY2C,IAAAA;AAAAA,UACJA,IAAc,EAClBC,qBAAqB,OACrBC,yBAAyB9D,CAAAA,OAAQA,GAAK+D,MAAM,CAAA,EAAA,CAAA;EAAA;EAIhDxD,MACEI,IACAqD,IAAAA;AAAAA,WAEIA,MAAWA,GAAQ1C,QACd2C,EAAIC,KAAKC,oBAAoBH,GAAQ1C,OAAOX,EAAAA,CAAAA,IAG9CyD,MAAM7D,MAAMI,EAAAA;EAAAA;AAAAA;AAAAA,IC3BV0D,IAAyBT;;;ACI/B,SAASU,GACdC,IACAC,IACAC,IAAAA;AAAAA,WAESC,KAAI,GAAGC,KAASJ,GAAMI,QAAQD,KAAIC,IAAQD;AAAAA,QAChB,MAA7BD,GAAQF,GAAMG,EAAAA,GAAIF,EAAAA;AAAAA,aAAAA;AACb,SAAA;AAIJ;AAGF,SAASI,GAA6BC,IAAiBC,IAAAA;AAAAA,SACrDC,MAAMC,QAAQH,EAAAA,KAAWI,OAAOC,MAAMD,OAAOH,EAAAA,CAAAA;AAAAA;AAGtD,SAASK,GAA8BN,IAAiBC,IAAeM,IAAAA;AAAAA,MAAAA,CAChER,GAA0BC,IAAQC,EAAAA;AAAAA,WAC9BM,GAAIP,IAAQC,EAAAA;AAAAA,MAGjBO,KAAoB,CAAA;AAAA,WAEfX,KAAI,GAAGA,KAAIG,GAAOF,QAAQD,MAAK;AAAA,UAChCF,KAAQY,GAAIP,GAAOH,EAAAA,GAAII,EAAAA;AAAAA,eAClBN,OACTa,KAASA,GAAOC,OAAOd,EAAAA;EAAAA;AAAAA,SAIpBa;AAAAA;AAsBF,SAASE,GAA2BC,IAAAA;AAAAA,SACjC,CAACC,IAAMZ,IAAQa,OAAAA;AAAAA,UACflB,KAAQkB,GAAQN,IAAIP,IAAQY,GAAKX,KAAAA;AAAAA,WAElCC,MAAMC,QAAQR,EAAAA,IAIZA,GAAMmB,KAAKC,CAAAA,OAAKJ,GAAKC,IAAMG,IAAGF,EAAAA,CAAAA,IAH5BF,GAAKC,IAAMjB,IAAOkB,EAAAA;EAAAA;AAAAA;AC7D/B,IAAMG,KAAa,CAAChB,IAAmBC,OAAkBD,GAAOC,EAAAA;AAGzD,SAASgB,GAAmCjB,IAAWkB,IAAcX,IAAAA;AAAAA,QACpEY,KAAWD,GAAKE,YAAY,GAAA;AAAA,SAAA,OAE9BD,KACK,CAACnB,IAAQkB,EAAAA,IAGX,CACLX,GAAIP,IAAQkB,GAAKG,MAAM,GAAGF,EAAAA,CAAAA,GAC1BD,GAAKG,MAAMF,KAAW,CAAA,CAAA;AAAA;AAInB,SAASG,GAAetB,IAAiBC,IAAcM,KAAgBS,IAAAA;AAAAA,MACxEf,OAAUsB;AAAAA,WACLvB;AAAAA,MAAAA,CAGJA;AAAAA,UACG,IAAIwB,MAAO,wBAAuBvB,cAAiBwB,OAAOzB,EAAAA,IAAAA;AAAAA,SDe7D,SAAwBA,IAAmBC,IAAeM,IAAAA;AAAAA,QAAAA,OAC3DN,GAAMyB,QAAQ,GAAA;AAAA,aACTpB,GAASN,IAAQC,IAAOM,EAAAA;AAAAA,UAG3BoB,KAAQ1B,GAAM2B,MAAM,GAAA;AAAA,QACtBjC,KAAQK;AAAAA,aAEHH,KAAI,GAAGC,KAAS6B,GAAM7B,QAAQD,KAAIC,IAAQD;AAAAA,UACjDF,KAAQW,GAASX,IAAOgC,GAAM9B,EAAAA,GAAIU,EAAAA,GAAAA,CAE7BZ,MAA0B,YAAA,OAAVA;AAAAA,eACZA;AAAAA,WAIJA;EAAAA,EC5BeK,IAAmCC,IAAOM,EAAAA;AAAAA;AAO3D,SAASsB,GAAWC,IAAMC,IAAAA;AAAAA,SAC3BD,OAAMC,KACD,IAGFD,KAAIC,KAAI,IAAA;AAAK;AAGf,SAASC,GAIdC,IACAC,KAAa,CAAA,GAAA;AAAA,SAENC,EAAkBF,IAAAA,OAAAA,OAAAA,EACvBG,KAAKC,IACLR,SAAAA,GAAAA,GACGK,EAAAA,CAAAA;AAAAA;AAAAA,ICrCMI,KAA0B,CAACC,IAAMC,IAAAA,EAAUC,WAAAA,GAAAA,MAC/CF,GAAKG,MAAMC,KAAKC,CAAAA,OAAaH,GAAUG,IAAWJ,EAAAA,CAAAA;ADoCpDN,ICjCMW,KAAiB,CAACN,IAAMC,IAAQM,OAAAA,CACnCR,GAAGC,IAAMC,IAAQM,EAAAA;ADgCpBZ,IC7BMa,KAA2B,CAACR,IAAMC,IAAAA,EAAUC,WAAAA,GAAAA,MAChDF,GAAKG,MAAMM,MAAMJ,CAAAA,OAAaH,GAAUG,IAAWJ,EAAAA,CAAAA;AD4BrDN,ICzBMe,KAA2B,CAACV,IAAMC,IAAAA,EAAUC,WAAAA,GAAAA,MAAAA,CAC/CA,GAAUF,GAAKG,MAAM,CAAA,GAAIF,EAAAA;ADwB5BN,ICrBMgB,KAAuB,CAACX,IAAMC,IAAAA,EAAUX,SAAAA,IAASO,KAAAA,GAAAA,MAAAA;AAAAA,QACtDM,KAAQN,GAAII,IAAQD,GAAKY,KAAAA;AAAAA,SAE3BC,MAAMC,QAAQX,EAAAA,KAAAA,CAAWU,MAAMC,QAAQd,GAAKG,KAAAA,IACvCY,GAASZ,IAAOH,GAAKG,OAAOb,EAAAA,IAGC,MAA/BA,GAAQa,IAAOH,GAAKG,KAAAA;AAAAA;ADctBR,ICXMqB,KAAgB,CAAChB,IAAMC,IAAQM,OAAAA,CAClCI,GAAGX,IAAMC,IAAQM,EAAAA;ADUpBZ,ICPMsB,KAAMC,GAA6B,CAAClB,IAAMG,IAAOI,OAAAA;AAAAA,QACtDY,KAASZ,GAAQjB,QAAQa,IAAOH,GAAKG,KAAAA;AAAAA,SACzB,MAAXgB,MAAAA,OAAgBA;AAAAA,CAAAA;ADKlBxB,ICFMyB,KAAKF,GAA6B,CAAClB,IAAMG,IAAOI,OAAAA,OACpDA,GAAQjB,QAAQa,IAAOH,GAAKG,KAAAA,CAAAA;ADC9BR,ICCM0B,KAAKH,GAA6B,CAAClB,IAAMG,IAAOI,OACb,MAAvCA,GAAQjB,QAAQa,IAAOH,GAAKG,KAAAA,CAAAA;ADF9BR,ICIM2B,KAAMJ,GAA6B,CAAClB,IAAMG,IAAOI,OAAAA;AAAAA,QACtDY,KAASZ,GAAQjB,QAAQa,IAAOH,GAAKG,KAAAA;AAAAA,SACzB,MAAXgB,MAA2B,MAAXA;AAAAA,CAAAA;ADNlBxB,ICSM4B,KAAoC,CAACvB,IAAMC,IAAAA,EAAUJ,KAAAA,GAAAA,MAAAA;AAAAA,MAC5DG,GAAKY,UAAUY;AAAAA,WAAAA,WACHvB;AAAAA,QAAAA,CAGTwB,IAAMb,EAAAA,IAASc,GAAyBzB,IAAQD,GAAKY,OAAOf,EAAAA,GAC7D8B,KAAQxB,CAAAA,OAAAA,CAAAA,CAAgBA,MAASA,GAAMyB,eAAehB,EAAAA,MAAWZ,GAAKG;AAAAA,SAErE0B,GAA0BJ,IAAMb,EAAAA,IAASa,GAAKrB,KAAKuB,EAAAA,IAAQA,GAAKF,EAAAA;AAAAA;ADjBlE9B,ICoBMmC,KAAMZ,GAA2C,CAAClB,IAAMG,OAC3C,YAAA,OAAVA,MAAsBA,KAAQH,GAAKG,MAAM,CAAA,MAAOH,GAAKG,MAAM,CAAA,CAAA;ADrBpER,ICwBMoC,KAAwD,CAAC/B,IAAMC,IAAAA,EAAUJ,KAAAA,GAAAA,MAAAA;AAAAA,QAAAA,CAC7EmC,IAAOpB,EAAAA,IAASc,GAAqBzB,IAAqBD,GAAKY,OAAOf,EAAAA,GACvE8B,KAAQF,CAAAA,OAAAA;AAAAA,UACNtB,KAAQN,GAAI4B,IAAMb,EAAAA;AAAAA,WACjBC,MAAMC,QAAQX,EAAAA,KAAUA,GAAM8B,WAAWjC,GAAKG;EAAAA;AAAAA,SAGhDH,GAAKY,UAAUY,KAAUK,GAA0BG,IAAOpB,EAAAA,IAC7DoB,GAAM5B,KAAKuB,EAAAA,IACXA,GAAKK,EAAAA;AAAAA;ADjCJrC,ICoCMuC,KAAQhB,GAAiC,CAAClB,IAAMG,OACnC,YAAA,OAAVA,MAAsBH,GAAKG,MAAMwB,KAAKxB,EAAAA,CAAAA;ADrC/CR,ICwCMwC,KAASjB,GAAqC,CAAClB,IAAMC,IAAAA,EAAUX,SAAAA,GAAAA,MACnEyB,GAASf,GAAKG,OAAOF,IAAQX,EAAAA,CAAAA;ADzC/BK,IC4CMyC,KAAqB,CAACpC,IAAMC,IAAQM,OAAAA,CAAa4B,GAAOnC,IAAMC,IAAQM,EAAAA;AD5C5EZ,IC8CM0C,KAAmC,CAACrC,IAAMC,IAAAA,EAAUX,SAAAA,IAASO,KAAAA,GAAAA,MAAAA;AAAAA,QAClEM,KAAQN,GAAII,IAAQD,GAAKY,KAAAA;AAAAA,SACxBC,MAAMC,QAAQX,EAAAA,KAAUH,GAAKG,MAAMM,MAAM6B,CAAAA,OAAKvB,GAASZ,IAAOmC,IAAGhD,EAAAA,CAAAA;AAAAA;ADhDnEK,ICmDM4C,KAAyC,CAACvC,IAAMC,IAAAA,EAAUC,WAAAA,IAAWL,KAAAA,GAAAA,MAAAA;AAAAA,QAC1EM,KAAQN,GAAII,IAAQD,GAAKY,KAAAA;AAAAA,SACxBC,MAAMC,QAAQX,EAAAA,KAAUA,GAAMC,KAAKkC,CAAAA,OAAKpC,GAAUF,GAAKG,OAAOmC,EAAAA,CAAAA;AAAAA;ADrDhE3C,ICyDM6C,KAAuD,CAACxC,IAAMC,OAClED,GAAKG,MAAMsC,KAAKxC,EAAAA;AAAAA,IAAAA,IAAAA,OAAAA,OAAAA,EAAAA,WAAAA,MAAAA,IAAAA,IAAAA,KAAAA,IAAAA,KAAAA,IAAAA,KAAAA,IAAAA,IAAAA,IAAAA,IAAAA,IAAAA,KAAAA,IAAAA,IAAAA,IAAAA,IAAAA,IAAAA,KAAAA,IAAAA,QAAAA,IAAAA,KAAAA,IAAAA,MAAAA,IAAAA,OAAAA,IAAAA,QAAAA,IAAAA,KAAAA,IAAAA,KAAAA,IAAAA,WAAAA,IAAAA,OAAAA,GAAAA,CAAAA;AAAAA,IC7GZyC,IAAAA,OAAAA,OAAAA,CAAAA,GACRC,GAAAA,EACHC,IAAID,GAAAA,CAAAA;AD2GmB1C,ICzGZC,IAAYT,GAAoBiD,CAAAA;;;ACkB7C,SAASG,GAAYC,IAAAA;AAAAA,SACfA,cAAiBC,OACZD,GAAME,QAAAA,IAGXF,MAAgD,cAAA,OAA/BA,GAAoBG,SAC/BH,GAAoBG,OAAAA,IAGvBH;AAAAA;AAGT,IAAMI,KAAoC,CAACC,IAAGC,OAAMC,GAAQR,GAAYM,EAAAA,GAAIN,GAAYO,EAAAA,CAAAA;AAyBjF,SAASE,GAIdC,IAAiBC,IAAiBC,IAAAA;AAAAA,QAC5BC,KAAS,IAAIC,EAAiBJ,EAAAA,GAC9BK,KAAYC,GAAoBL,IAAAA,OAAAA,OAAAA,EACpCH,SAASH,GAAAA,GACNO,EAAAA,CAAAA;AAAAA,MAGDA,MAAWA,GAAQK,eAAe;AAAA,UAC9BC,KAAS,EAAEC,OAAOC,EAAAA,GAClBC,KAAQR,GAAOQ;AACrBR,IAAAA,GAAOS,SAASC,CAAAA,OAASF,GAAME,IAAOL,EAAAA,CAAAA;EAAAA;AAAAA,SAGjCM,EAAwBX,GAAOQ,OAAON,EAAAA;AAAAA;AAAAA,IAGlCU,KAAQhB,GAAciB,GAAwBC,CAAAA;AAHZZ,IAkBlCa,KAASnB,GAbI,CAAC,QAAQ,KAAA,EACuBoB,OAAO,CAACnB,IAAcoB,QAC9EpB,GAAaoB,EAAAA,IAAAA,OAAAA,OAAAA,CAAAA,GAAapB,GAAaoB,EAAAA,GAAAA,EAAOC,MAAM,QAAA,CAAA,GAC7CrB,KAAAA,OAAAA,OAAAA,CAAAA,GAEJgB,GAAAA,EACHM,MAAAA,OAAAA,OAAAA,CAAAA,GACKN,EAAuBM,MAAAA,EAC1BD,MAAM,SACNV,OAAOY,EAAeC,SAAAA,CAAAA,EAAAA,CAAAA,CAAAA,GAI2CP,GAAiB,EACpFV,eAAAA,KAAe,CAAA;;;AClG+T,SAASkB,GAAEC,IAAE;AAAC,SAAO,MAAM,QAAQA,EAAC,IAAEA,KAAE,CAACA,EAAC;AAAC;AAAC,IAAM,IAAE,OAAO,UAAQ,OAAO,UAAU,eAAe,KAAK,KAAK,OAAO,UAAU,cAAc;AAAE,IAAMC,KAAE;AAAsB,SAASC,GAAEF,IAAEG,IAAE;AAAC,MAAGA;AAAE,QAAG,CAAC,EAAEA,IAAEF,EAAC;AAAE,aAAO,eAAeE,IAAEF,IAAE,EAAC,OAAMD,GAAC,CAAC;AAAA,aAAUA,OAAIG,GAAEF,EAAC;AAAE,YAAM,IAAI,MAAM,yCAAyCD,sCAAqCG,GAAEF,EAAC,GAAG;AAAA;AAAE,SAAOE;AAAC;AAAC,IAAMC,KAAE,CAAAJ,OAAG;AAAC,QAAMG,KAAE,OAAOH;AAAE,SAAM,aAAWG,MAAG,eAAaA;AAAC;AAAE,IAAM,IAAE,CAAAH,OAAGA,GAAE,aAAWA,GAAE;AAAK,IAAM,IAAE,CAAAA,OAAG,aAAW,OAAOA,KAAEA,KAAE,EAAEA,EAAC;AAAE,SAASK,GAAEL,IAAE;AAAC,MAAG,EAAEA,IAAEC,EAAC;AAAE,WAAOD,GAAEC,EAAC;AAAE,SAAO,EAAED,GAAE,WAAW;AAAC;AAAC,SAASM,GAAEN,IAAEG,IAAEI,IAAE;AAAC,MAAIC,KAAET,GAAEI,EAAC;AAAE,MAAIM,KAAE;AAAE,SAAMA,KAAED,GAAE,QAAO;AAAC,UAAML,KAAEK,GAAEC,IAAG;AAAE,QAAG,EAAET,IAAEG,EAAC;AAAE,MAAAK,KAAED,GAAEC,IAAER,GAAEG,EAAC,CAAC;AAAA,EAAC;AAAC,SAAOK;AAAC;AAAC,SAAS,EAAER,IAAEG,IAAE;AAAC,MAAG,aAAW,OAAOA,MAAG,OAAKH,GAAE,QAAQG,EAAC;AAAE,WAAOA;AAAE,WAAQI,KAAE,GAAEA,KAAEJ,GAAE,QAAOI;AAAI,QAAG,OAAKP,GAAE,QAAQG,GAAEI,EAAC,CAAC;AAAE,aAAOJ,GAAEI,EAAC;AAAE,SAAO;AAAI;AAAC,IAAM,IAAE,CAACP,IAAEG,OAAIH,GAAE,OAAOG,EAAC;AAAE,SAAS,EAAEH,IAAEG,IAAE;AAAC,MAAGA,MAAKH;AAAE,UAAM,IAAI,MAAM,eAAeG,+CAA8C;AAAE,QAAMI,KAAE,OAAO,KAAKP,EAAC;AAAE,QAAMQ,KAAE,CAACR,IAAEO,OAAI;AAAC,UAAMC,KAAE,EAAER,IAAEO,EAAC;AAAE,QAAGC;AAAE,YAAM,IAAI,MAAM,kBAAkBA,SAAQR,GAAE,KAAK,IAAI,GAAG;AAAE,UAAMS,KAAE,aAAW,OAAOF,MAAGA,OAAIJ,MAAG,OAAKH,GAAE,QAAQG,EAAC,KAAG,MAAM,QAAQI,EAAC,KAAG,OAAKA,GAAE,QAAQJ,EAAC;AAAE,QAAGM;AAAE,YAAM,IAAI,MAAM,4BAA4BN,qCAAoC;AAAE,WAAOH,GAAE,OAAOO,EAAC;AAAA,EAAC;AAAE,WAAQJ,KAAE,GAAEA,KAAEI,GAAE,QAAOJ;AAAI,IAAAG,GAAEN,IAAEO,GAAEJ,EAAC,GAAEK,EAAC;AAAC;AAAC,SAAS,EAAER,IAAEG,IAAE;AAAC,MAAG,CAACA,MAAG,UAAQA,GAAE;AAAa,MAAEH,IAAEG,MAAGA,GAAE,aAAW,QAAQ;AAAE,SAAO,CAAAA,OAAGG,GAAEN,IAAEG,IAAE,CAAC;AAAC;AAAC,SAAS,EAAEH,IAAEG,IAAEI,IAAE;AAAC,WAAQC,KAAED,IAAEC,KAAEL,GAAE,QAAOK;AAAI,IAAAR,GAAE,KAAKG,GAAEK,EAAC,CAAC;AAAC;AAAC,SAASE,GAAEV,IAAEG,IAAE;AAAC,MAAG,CAACH,MAAG,CAACA,GAAE;AAAO,WAAOG,MAAG,CAAC;AAAE,MAAG,CAACA,MAAG,CAACA,GAAE;AAAO,WAAOH,MAAG,CAAC;AAAE,MAAIO,KAAE;AAAE,MAAIC,KAAE;AAAE,QAAMC,KAAE,CAAC;AAAE,SAAMF,KAAEP,GAAE,UAAQQ,KAAEL,GAAE;AAAO,QAAGH,GAAEO,EAAC,EAAE,WAASJ,GAAEK,EAAC,EAAE,UAAS;AAAC,MAAAC,GAAE,KAAKT,GAAEO,EAAC,CAAC;AAAE,MAAAA;AAAA,IAAG,OAAK;AAAC,MAAAE,GAAE,KAAKN,GAAEK,EAAC,CAAC;AAAE,MAAAA;AAAA,IAAG;AAAC,IAAEC,IAAET,IAAEO,EAAC;AAAE,IAAEE,IAAEN,IAAEK,EAAC;AAAE,SAAOC;AAAC;AAAC,SAAS,EAAET,IAAEG,IAAEI,IAAE;AAAC,MAAIC,KAAER,GAAE,IAAIG,EAAC;AAAE,MAAG,CAACK,IAAE;AAAC,IAAAA,KAAED,GAAE;AAAE,IAAAP,GAAE,IAAIG,IAAEK,EAAC;AAAA,EAAC;AAAC,SAAOA;AAAC;AAAC,IAAM,IAAE,CAAAR,OAAGA;AAAE,SAAS,EAAEA,IAAEG,IAAE;AAAC,MAAG,MAAM,QAAQH,GAAE,MAAM,KAAG,CAACA,GAAE,OAAO;AAAO,UAAM,IAAI,MAAM,mEAAmE;AAAE,MAAGA,GAAE,UAAQ,CAACG,GAAE;AAAa,UAAM,IAAI,MAAM,8EAA8E;AAAE,MAAGH,GAAE,cAAY,CAACG,GAAE;AAAkB,UAAM,IAAI,MAAM,uFAAuF;AAAC;AAAC,IAAM,IAAN,MAAO;AAAA,EAAC,YAAYH,IAAEG,IAAEI,KAAE,GAAE;AAAC,MAAEP,IAAEG,EAAC;AAAE,SAAK,SAAOA,GAAE,cAAcH,GAAE,MAAM;AAAE,SAAK,UAAQA,GAAE;AAAQ,SAAK,WAAS,CAAC,CAACA,GAAE;AAAS,SAAK,aAAWA,GAAE;AAAW,SAAK,SAAOA,GAAE;AAAO,SAAK,SAAOA;AAAE,SAAK,SAAOA,GAAE,SAAOD,GAAEC,GAAE,MAAM,IAAE;AAAO,SAAK,WAASO;AAAE,SAAK,IAAEJ;AAAA,EAAC;AAAA,EAAC,IAAG;AAAC,QAAG,KAAK,cAAY,CAAC,KAAK;AAAE,WAAK,IAAE,KAAK,EAAE,kBAAkB,KAAK,UAAU;AAAE,WAAO,KAAK;AAAA,EAAC;AAAA,EAAC,IAAI,MAAK;AAAC,UAAMH,KAAE,KAAK,EAAE;AAAE,WAAOA,KAAEA,GAAE,MAAI;AAAA,EAAM;AAAA,EAAC,kBAAkBA,IAAE;AAAC,QAAG,CAAC,KAAK;AAAW,aAAO;AAAK,QAAG,CAACA,MAAGI,GAAEJ,EAAC;AAAE,aAAM,CAAC,KAAK;AAAS,UAAMG,KAAE,KAAK,EAAE;AAAE,WAAOA,GAAEH,EAAC;AAAA,EAAC;AAAA,EAAC,aAAaA,IAAE;AAAC,QAAG,CAAC,KAAK;AAAO,aAAO;AAAK,QAAG,CAACA;AAAE,aAAM,CAAC,KAAK;AAAS,QAAG,KAAK,UAAQ,CAAC,KAAK;AAAE,WAAK,IAAE,KAAK,EAAE,aAAa,KAAK,MAAM;AAAE,WAAO,KAAK,EAAEA,EAAC;AAAA,EAAC;AAAC;AAAC,SAASW,GAAEX,IAAEG,IAAE;AAAC,QAAMI,KAAE,EAAC,OAAMP,IAAE,MAAKG,IAAE,MAAK,KAAI;AAAE,MAAGA;AAAE,IAAAA,GAAE,OAAKI;AAAE,SAAOA;AAAC;AAAC,SAAS,EAAEP,IAAE;AAAC,MAAGA,GAAE;AAAK,IAAAA,GAAE,KAAK,OAAKA,GAAE;AAAK,MAAGA,GAAE;AAAK,IAAAA,GAAE,KAAK,OAAKA,GAAE;AAAK,EAAAA,GAAE,OAAKA,GAAE,OAAK;AAAI;AAAC,IAAM,IAAE,CAAAA,QAAI,EAAC,OAAMA,GAAE,OAAM,MAAKA,GAAE,MAAK,MAAKA,GAAE,KAAI;AAAG,IAAM,IAAE,OAAK,EAAC,OAAM,CAAC,GAAE,QAAO,MAAK;AAAG,IAAM,IAAE,MAAI,oBAAI;AAAI,IAAM,IAAN,MAAO;AAAA,EAAC,YAAYA,KAAE,CAAC,GAAEG,KAAE,CAAC,GAAE;AAAC,SAAK,IAAE;AAAM,SAAK,IAAE,EAAC,mBAAkBA,GAAE,mBAAkB,cAAaA,GAAE,cAAa,eAAcA,GAAE,iBAAe,EAAC;AAAE,SAAK,IAAEA,GAAE,aAAW;AAAS,SAAK,IAAEA,GAAE,kBAAgB;AAAM,SAAK,IAAEA,GAAE,qBAAmBE;AAAE,SAAK,IAAEL;AAAE,SAAK,IAAE,KAAK,EAAEA,EAAC;AAAA,EAAC;AAAA,EAAC,IAAI,QAAO;AAAC,WAAO,KAAK;AAAA,EAAC;AAAA,EAAC,kBAAkBA,IAAE;AAAC,QAAGI,GAAEJ,EAAC;AAAE,aAAOA;AAAE,QAAG,CAACA;AAAE,aAAO,KAAK;AAAE,WAAO,KAAK,EAAEA,EAAC;AAAA,EAAC;AAAA,EAAC,OAAOA,IAAE;AAAC,UAAMG,KAAE,EAAC,OAAMH,IAAE,SAAQ,MAAK,QAAO,KAAI;AAAE,SAAK,EAAE,UAASG,EAAC;AAAE,SAAK,IAAEH;AAAE,SAAK,IAAE,KAAK,EAAEA,EAAC;AAAE,SAAK,EAAE,WAAUG,EAAC;AAAE,WAAO;AAAA,EAAI;AAAA,EAAC,EAAEH,IAAE;AAAC,UAAMG,KAAE,oBAAI;AAAI,aAAQI,KAAEP,GAAE,SAAO,GAAEO,MAAG,GAAEA,MAAI;AAAC,YAAMC,KAAER,GAAE,SAAOO,KAAE;AAAE,YAAME,KAAE,IAAI,EAAET,GAAEO,EAAC,GAAE,KAAK,GAAEC,EAAC;AAAE,YAAMI,KAAEb,GAAEU,GAAE,MAAM;AAAE,YAAMI,KAAEd,GAAEU,GAAE,WAAS,KAAK,CAAC;AAAE,UAAG,CAAC,KAAK,KAAGA,GAAE;AAAO,aAAK,IAAE;AAAK,eAAQT,KAAE,GAAEA,KAAEa,GAAE,QAAOb,MAAI;AAAC,cAAMO,KAAE,EAAEJ,IAAEU,GAAEb,EAAC,GAAE,CAAC;AAAE,iBAAQA,KAAE,GAAEA,KAAEY,GAAE,QAAOZ;AAAI,YAAEO,IAAEK,GAAEZ,EAAC,GAAE,CAAC,EAAE,MAAM,KAAKS,EAAC;AAAA,MAAC;AAAA,IAAC;AAAC,WAAON;AAAA,EAAC;AAAA,EAAC,iBAAiBH,IAAEG,KAAE,KAAK,GAAE;AAAC,QAAG,CAACC,GAAED,EAAC;AAAE,YAAM,IAAI,MAAM,4FAA4F;AAAE,UAAMI,KAAE,EAAE,KAAK,GAAEJ,IAAE,CAAC;AAAE,UAAMK,KAAE,EAAED,IAAEP,IAAE,CAAC;AAAE,QAAGQ,GAAE;AAAO,aAAOA,GAAE;AAAM,UAAMC,KAAET,OAAI,KAAK,KAAGO,GAAE,IAAI,KAAK,CAAC,IAAEA,GAAE,IAAI,KAAK,CAAC,EAAE,QAAM;AAAO,QAAIK,KAAEF,GAAEF,GAAE,OAAMC,EAAC;AAAE,QAAGN,OAAI,KAAK;AAAE,MAAAS,KAAEF,GAAEE,IAAE,KAAK,iBAAiBZ,IAAE,KAAK,CAAC,CAAC;AAAE,IAAAQ,GAAE,QAAMI;AAAE,IAAAJ,GAAE,SAAO;AAAK,WAAOI;AAAA,EAAC;AAAA,EAAC,SAASZ,IAAEG,IAAEI,IAAE;AAAC,UAAMC,KAAE,KAAK,iBAAiBR,IAAEG,EAAC;AAAE,QAAGI,MAAG,aAAW,OAAOA;AAAE,YAAM,IAAI,MAAM,+IAA+I;AAAE,QAAG,CAAC,KAAK;AAAE,aAAOC;AAAE,WAAOA,GAAE,OAAQ,CAAAR,OAAGA,GAAE,aAAaO,EAAC,CAAE;AAAA,EAAC;AAAA,EAAC,WAAWP,IAAE;AAAC,QAAG,CAACI,GAAEJ,EAAC;AAAE,YAAM,IAAI,MAAM,gFAAgF;AAAE,UAAMG,KAAE,oBAAI;AAAI,UAAMI,KAAE,KAAK,EAAE,IAAIP,EAAC;AAAE,QAAGO;AAAE,YAAM,KAAKA,GAAE,KAAK,CAAC,EAAE,QAAS,CAAAP,OAAGG,GAAE,IAAIH,EAAC,CAAE;AAAE,UAAMQ,KAAER,OAAI,KAAK,IAAE,KAAK,EAAE,IAAI,KAAK,CAAC,IAAE;AAAO,QAAGQ;AAAE,YAAM,KAAKA,GAAE,KAAK,CAAC,EAAE,QAAS,CAAAR,OAAGG,GAAE,IAAIH,EAAC,CAAE;AAAE,WAAO,MAAM,KAAKG,EAAC;AAAA,EAAC;AAAA,EAAC,GAAGH,IAAEG,IAAE;AAAC,SAAK,IAAE,KAAK,KAAG,oBAAI;AAAI,UAAMI,KAAE,KAAK;AAAE,UAAMC,KAAED,GAAE,IAAIP,EAAC,KAAG;AAAK,UAAMS,KAAEE,GAAER,IAAEK,EAAC;AAAE,IAAAD,GAAE,IAAIP,IAAES,EAAC;AAAE,WAAM,MAAI;AAAC,YAAMN,KAAEI,GAAE,IAAIP,EAAC;AAAE,UAAG,CAACS,GAAE,QAAM,CAACA,GAAE,QAAMN,OAAIM;AAAE,QAAAF,GAAE,OAAOP,EAAC;AAAA,eAAUS,OAAIN;AAAE,QAAAI,GAAE,IAAIP,IAAES,GAAE,IAAI;AAAE,QAAEA,EAAC;AAAA,IAAC;AAAA,EAAC;AAAA,EAAC,EAAET,IAAEG,IAAE;AAAC,QAAG,CAAC,KAAK;AAAE;AAAO,QAAII,KAAE,KAAK,EAAE,IAAIP,EAAC,KAAG;AAAK,WAAM,SAAOO,IAAE;AAAC,YAAMP,KAAEO,GAAE,OAAK,EAAEA,GAAE,IAAI,IAAE;AAAK,MAAAA,GAAE,MAAMJ,EAAC;AAAE,MAAAI,KAAEP;AAAA,IAAC;AAAA,EAAC;AAAC;AAAC,IAAM,cAAN,cAA0B,EAAC;AAAA,EAAC,IAAIA,IAAEG,IAAEI,IAAE;AAAC,UAAMC,KAAE,KAAK,gBAAgBR,IAAEG,IAAEI,EAAC;AAAE,WAAM,CAAC,CAACC,MAAG,CAACA,GAAE;AAAA,EAAQ;AAAA,EAAC,gBAAgBR,IAAEG,IAAEI,IAAE;AAAC,UAAMC,KAAE,KAAK,kBAAkBL,EAAC;AAAE,UAAMM,KAAE,KAAK,SAAST,IAAEQ,IAAED,EAAC;AAAE,aAAQP,KAAE,GAAEO,KAAEE,GAAE,QAAOT,KAAEO,IAAEP;AAAI,UAAGS,GAAET,EAAC,EAAE,kBAAkBG,EAAC;AAAE,eAAOM,GAAET,EAAC;AAAE,WAAO;AAAA,EAAI;AAAA,EAAC,OAAOA,IAAEG,IAAEI,IAAE;AAAC,WAAM,CAAC,KAAK,IAAIP,IAAEG,IAAEI,EAAC;AAAA,EAAC;AAAC;AAAC,IAAM,KAAG,EAAC,KAAIR,IAAE,KAAI,GAAE,KAAI,GAAE,MAAKe,IAAE,KAAI,GAAE,MAAK,GAAE,KAAIC,IAAE,MAAKC,IAAE,MAAKC,IAAE,OAAMC,IAAE,QAAOC,IAAE,UAAS,GAAE,YAAW,GAAE,SAAQC,GAAC;AAAE,IAAM,KAAG,EAAC,IAAGC,IAAE,IAAGC,IAAE,IAAGC,IAAE,KAAIC,IAAE,IAAGV,IAAE,KAAII,IAAE,IAAGP,IAAE,KAAIc,IAAE,KAAIpB,IAAE,MAAKW,IAAE,OAAMjB,IAAE,WAAUO,IAAE,QAAOa,IAAE,KAAIC,GAAC;AAAE,IAAM,KAAG,CAACjB,IAAEI,IAAEC,OAAIkB,GAAE,OAAO,OAAO,CAAC,GAAE,IAAGvB,EAAC,GAAE,OAAO,OAAO,CAAC,GAAE,IAAGI,EAAC,GAAEC,EAAC;AAAE,IAAM,KAAGkB,GAAE,IAAG,EAAE;AAAE,IAAM,KAAG;AAAuB,IAAM,KAAG;AAAa,IAAM,KAAG;AAAM,IAAM,KAAG;AAAM,SAAS,GAAG1B,IAAEG,IAAEI,IAAE;AAAC,QAAMC,KAAE,QAAMD,GAAE,CAAC,KAAG,QAAMP,GAAE,CAAC,KAAG,QAAMA,GAAEA,GAAE,SAAO,CAAC,IAAE,MAAI;AAAI,QAAMS,KAAE,OAAKT,GAAE,QAAQ,IAAI,IAAE,SAAO;AAAI,QAAMY,KAAEZ,GAAE,QAAQ,IAAG,MAAM,EAAE,QAAQ,IAAGS,KAAED,EAAC;AAAE,SAAOL,KAAEH,GAAE,WAASO,GAAE,SAAO,MAAMK,SAAMA;AAAC;AAAC,SAAS,GAAGZ,IAAEG,IAAEI,IAAE;AAAC,MAAG,QAAMP,OAAI,QAAMO,GAAEJ,KAAE,CAAC,KAAG,QAAMI,GAAEJ,KAAE,CAAC;AAAG,WAAOH;AAAE,SAAM,KAAKA;AAAG;AAAC,SAAS,GAAGA,IAAE;AAAC,QAAMG,KAAEH,GAAE,IAAK,CAAAA,OAAGA,GAAE,QAAQ,IAAG,EAAE,EAAE,QAAQ,IAAG,EAAE,CAAE;AAAE,QAAMO,KAAEJ,GAAE,SAAO,IAAE,MAAMA,GAAE,KAAK,GAAG,OAAKA,GAAE,CAAC;AAAE,SAAO,IAAI,OAAO,IAAII,KAAI;AAAC;AAAC,IAAM,KAAG,CAAAP,OAAG;AAAC,MAAIG;AAAE,SAAO,CAAAI,OAAG;AAAC,QAAG,gBAAc,OAAOJ;AAAE,MAAAA,KAAEH,GAAE,MAAO,CAAAA,OAAG,OAAKA,GAAE,QAAQ,GAAG,CAAE,IAAE,OAAK,GAAGA,EAAC;AAAE,WAAO,SAAOG,KAAE,OAAKH,GAAE,QAAQO,EAAC,IAAEJ,GAAE,KAAKI,EAAC;AAAA,EAAC;AAAC;AAAE,IAAM,UAAN,cAAsB,YAAW;AAAA,EAAC,YAAYP,KAAE,CAAC,GAAEG,KAAE,CAAC,GAAE;AAAC,UAAMH,IAAE,OAAO,OAAO,EAAC,mBAAkB,IAAG,cAAa,GAAE,GAAEG,EAAC,CAAC;AAAA,EAAC;AAAC;AAAC,SAAS,mBAAmBH,KAAE,CAAC,GAAEG,KAAE,CAAC,GAAE;AAAC,SAAO,IAAI,YAAYH,IAAE,OAAO,OAAO,EAAC,mBAAkB,IAAG,cAAa,GAAE,GAAEG,EAAC,CAAC;AAAC;AAAC,SAAS,eAAeH,IAAE;AAAC,SAAM,eAAa,OAAOA,GAAE,UAAU;AAAgB;AAAC,IAAM,KAAN,MAAQ;AAAA,EAAC,YAAYA,IAAE;AAAC,SAAK,IAAEA;AAAA,EAAC;AAAA,EAAC,QAAQA,IAAE;AAAC,SAAK,EAAE,SAAOA;AAAE,WAAO;AAAA,EAAI;AAAC;AAAC,IAAM,iBAAN,MAAoB;AAAA,EAAC,YAAYA,IAAE;AAAC,SAAK,QAAM,CAAC;AAAE,SAAK,IAAEA;AAAE,SAAK,MAAI,CAACA,IAAEG,IAAEI,IAAEC,OAAI,KAAK,EAAER,IAAEG,IAAEI,IAAEC,IAAE,KAAK;AAAE,SAAK,SAAO,CAACR,IAAEG,IAAEI,IAAEC,OAAI,KAAK,EAAER,IAAEG,IAAEI,IAAEC,IAAE,IAAI;AAAE,SAAK,QAAM,CAAAR,OAAG,eAAe,KAAK,CAAC,IAAE,IAAI,KAAK,EAAE,KAAK,OAAMA,EAAC,IAAE,KAAK,EAAE,KAAK,OAAMA,EAAC;AAAA,EAAC;AAAA,EAAC,EAAEA,IAAEG,IAAEI,IAAEC,IAAEC,IAAE;AAAC,UAAMG,KAAE,EAAC,QAAOZ,GAAC;AAAE,QAAGS;AAAE,MAAAG,GAAE,WAASH;AAAE,QAAGN,IAAE;AAAC,MAAAS,GAAE,UAAQT;AAAE,UAAG,MAAM,QAAQI,EAAC,KAAG,aAAW,OAAOA;AAAE,QAAAK,GAAE,SAAOL;AAAA,eAAU,gBAAc,OAAOA;AAAE,QAAAK,GAAE,aAAWL;AAAE,UAAG,gBAAc,OAAOC;AAAE,QAAAI,GAAE,aAAWJ;AAAA,IAAC;AAAC,SAAK,MAAM,KAAKI,EAAC;AAAE,WAAO,IAAI,GAAGA,EAAC;AAAA,EAAC;AAAC;AAAC,SAAS,cAAcZ,IAAEG,IAAE;AAAC,QAAMI,KAAE,IAAI,eAAe,kBAAkB;AAAE,QAAMC,KAAER,GAAEO,GAAE,KAAIA,GAAE,MAAM;AAAE,MAAGC,MAAG,eAAa,OAAOA,GAAE;AAAK,WAAOA,GAAE,KAAM,MAAID,GAAE,MAAMJ,EAAC,CAAE;AAAE,SAAOI,GAAE,MAAMJ,EAAC;AAAC;AAAC,IAAM,KAAG,CAAAH,OAAG,mBAAmBA,GAAE,eAAeA,GAAE;AAAe,IAAM,KAAG,SAASA,GAAEG,IAAE;AAAC,OAAK,UAAQA;AAAC;AAAE,GAAG,YAAU,OAAO,OAAO,MAAM,SAAS;AAAE,IAAM,iBAAN,cAA6B,GAAE;AAAA,EAAC,OAAO,kBAAkBH,IAAE;AAAC,SAAK,IAAE,aAAW,OAAOA,KAAE,MAAIA,KAAEA;AAAA,EAAC;AAAA,EAAC,OAAO,KAAKA,IAAE;AAAC,WAAO,IAAI,KAAKA,EAAC;AAAA,EAAC;AAAA,EAAC,YAAYA,IAAE;AAAC,UAAM,EAAE;AAAE,SAAK,UAAQA;AAAE,QAAG,eAAa,OAAO,MAAM,mBAAkB;AAAC,WAAK,OAAK;AAAiB,YAAM,kBAAkB,MAAK,KAAK,WAAW;AAAA,IAAC;AAAA,EAAC;AAAA,EAAC,WAAWA,IAAE;AAAC,SAAK,UAAQA;AAAE,WAAO;AAAA,EAAI;AAAA,EAAC,eAAeA,IAAEG,IAAEI,IAAE;AAAC,UAAMC,KAAE,KAAK,UAAUR,IAAEG,IAAEI,EAAC;AAAE,QAAGC;AAAE,YAAMA;AAAA,EAAC;AAAA,EAAC,UAAUR,IAAEG,IAAEI,IAAE;AAAC,UAAMC,KAAE,KAAK,QAAQ,gBAAgBR,IAAEG,IAAEI,EAAC;AAAE,QAAGC,MAAG,CAACA,GAAE;AAAS;AAAO,SAAK,SAAOR;AAAE,SAAK,UAAQG;AAAE,SAAK,cAAY,EAAE,KAAK,QAAQ,kBAAkBA,EAAC,CAAC;AAAE,SAAK,QAAMI;AAAE,UAAME,KAAED,KAAEA,GAAE,SAAO;AAAG,SAAK,UAAQ,KAAK,WAASC,MAAG,KAAK,YAAY,EAAE,IAAI;AAAE,WAAO;AAAA,EAAI;AAAC;AAAC,eAAe,IAAE;AAAG,IAAI,KAAG,OAAO,OAAO,EAAC,WAAU,KAAI,CAAC;",
  "names": ["Condition", "constructor", "operator", "value", "Object", "defineProperty", "this", "writable", "_notes", "addNote", "note", "push", "DocumentCondition", "CompoundCondition", "conditions", "Array", "isArray", "Error", "ITSELF", "FieldCondition", "field", "NULL_CONDITION", "hasOwnProperty", "prototype", "call", "bind", "isCompound", "condition", "optimizedCompoundCondition", "length", "flattenConditions", "aggregatedResult", "flatConditions", "i", "currentNode", "identity", "x", "object", "create", "ignoreValue", "hasOperators", "instructions", "skipIgnore", "prop", "objectKeysSkipIgnore", "anyObject", "keys", "key", "pushIfNonNullCondition", "buildAnd", "condition", "defaultInstructionParsers", "compound", "instruction", "value", "context", "conditions", "Array", "isArray", "map", "query", "parse", "CompoundCondition", "name", "field", "FieldCondition", "document", "DocumentCondition", "ObjectQueryParser", "constructor", "instructions", "options", "object", "_instructions", "_fieldInstructionContext", "_documentInstructionContext", "_options", "_objectKeys", "this", "bind", "operatorToConditionName", "identity", "defaultOperatorName", "mergeFinalConditions", "buildAnd", "Object", "keys", "reduce", "all", "fieldContext", "hasOperators", "useIgnoreValue", "documentContext", "objectKeysSkipIgnore", "setParse", "parseField", "operator", "parentQuery", "Error", "type", "parseInstruction", "validate", "parseFieldOperators", "i", "length", "op", "pushIfNonNullCondition", "key", "push", "getInterpreter", "interpreters", "interpret", "defaultInterpreterName", "createInterpreter", "rawOptions", "getInterpreterName", "numberOfArguments", "interpreterName", "defaultContext", "params", "createTranslatorFactory", "args", "ast", "translate", "prototype", "ensureIsArray", "instruction", "value", "Array", "isArray", "Error", "name", "ensureIsNonEmptyArray", "length", "ensureIs", "type", "$and", "validate", "parse", "queries", "conditions", "map", "query", "optimizedCompoundCondition", "$or", "$nor", "$not", "RegExp", "constructor", "Object", "context", "condition", "FieldCondition", "field", "CompoundCondition", "$elemMatch", "hasOperators", "ITSELF", "$size", "$in", "$nin", "$all", "$mod", "$exists", "$gte", "Date", "$gt", "$lt", "$lte", "$eq", "$ne", "$regex", "rawValue", "$options", "NULL_CONDITION", "$where", "c", "f", "d", "u", "w", "y", "x", "v", "h", "m", "j", "O", "_", "MongoQueryParser", "ObjectQueryParser", "instructions", "defaultOperatorName", "operatorToConditionName", "slice", "options", "and", "this", "parseFieldOperators", "super", "allParsingInstructions", "includes", "items", "value", "compare", "i", "length", "isArrayAndNotNumericField", "object", "field", "Array", "isArray", "Number", "isNaN", "getField", "get", "result", "concat", "testValueOrArray", "test", "node", "context", "some", "v", "defaultGet", "getObjectFieldCursor", "path", "dotIndex", "lastIndexOf", "slice", "getObjectField", "ITSELF", "Error", "String", "indexOf", "paths", "split", "compare", "a", "b", "createJsInterpreter", "operators", "options", "createInterpreter", "get", "getObjectField", "or", "node", "object", "interpret", "value", "some", "condition", "nor", "context", "and", "every", "not", "eq", "field", "Array", "isArray", "includes", "ne", "lte", "testValueOrArray", "result", "lt", "gt", "gte", "exists", "ITSELF", "item", "getObjectFieldCursor", "test", "hasOwnProperty", "isArrayAndNotNumericField", "mod", "size", "items", "length", "regex", "within", "nin", "all", "v", "elemMatch", "where", "call", "allInterpreters", "interpreters", "in", "toPrimitive", "value", "Date", "getTime", "toJSON", "comparePrimitives", "a", "b", "compare", "createFactory", "instructions", "interpreters", "options", "parser", "MongoQueryParser", "interpret", "createJsInterpreter", "forPrimitives", "params", "field", "ITSELF", "parse", "setParse", "query", "createTranslatorFactory", "guard", "allParsingInstructions", "allInterpreters", "squire", "reduce", "name", "type", "$nor", "defaultParsers", "compound", "O", "t", "R", "P", "e", "S", "q", "z", "i", "s", "n", "U", "N", "r", "o", "j", "y", "x", "v", "w", "_", "m", "b", "A", "h", "d", "$", "p"]
}
